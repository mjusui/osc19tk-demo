# Expose HTTP endpoint

An interface (query, test, command) defined in your class extends `Submarine` can be exposed with 'communicate' function.

```
const Submarine=require('Submarine');

const ExportHttpEndpoint=class extends Submarine {
  query(){
    return {
      hostname: 'hostname -s',

      ip_addrs: String.raw`
        ip -o -f inet a \
          |awk '{print $4}'
      `,

      tail: String.raw`
        sudo tail -n 6 \
          /var/log/syslog
      `,
    };
  }
}


const endpoint=new ExportHttpEndpoint({
  conn: 'ssh',
  host: 'server1',
});


endpoint.communicate({
  port: 30117,
  pathname: '/logs/syslog',
  cache: 5 * 1024,
  get: sub => sub.current(),
});
```

You run this code and the shell command,

```
$ curl lcoalhost:30117/logs/syslog
```

then you will get a JSON-formatted result of `current` function.

`communicate` function is implemented in `Submarine`, which takes an option(detailed bellow) and then starts an HTTP server to export interface you defined.

* An option taken by `communicate` function:  
  * pathname: URL pathname you want to service (required)
  * port: URL port you want to service (default 30117)
  * cache: cache time(milli second) you want to cache response (default 0, affects responses to `GET` request)
  * get: function to create the response at the time when  new `GET` request comes, which takes an instance itself as an argument (default `check()`).
  * post: function to create the response at the time when  new `POST` request comes, which takes an instance itself as an argument (default `correct()`).

All queries and body of requests are ignored, that is why security risk of injection could be avoided.

