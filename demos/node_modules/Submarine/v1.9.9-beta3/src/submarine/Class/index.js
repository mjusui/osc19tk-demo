'use strict';
require('extended');
const assert=require('assert').strict;
const Conn=require('conn/Class');
const Cont=require('cont/Class');
const { Pub }=require('comm/Classes');
const {
  GetSubJson,
  PutSubJson,
  PostSubJson,
}=require('submarine/consume/json/Classes');
const {
  GetSubHtml,
}=require('submarine/consume/html/Classes');
const coll=require('coll')
const time=require('cache/time/save');
const token=require('cache/token');


const Communicable=class {
  communicate(opt){
    const pub=Pub.port({
      port: 30117,
    });

    typeof opt.html === 'string'
      && new GetSubHtml({
           pathname: opt.html,
           response: time(
             none => this.check(),
             opt.cache || 3400
           ),
         }).sub(pub);

    /*(  typeof opt.oembed === 'string'
      && typeof opt.html === 'string')
    && new GetSubOembed({
         pathname: opt.oembed,
         response: time(
           none => this.check(r=>r)
         ),
       }).sub(pub);*/

    (typeof opt.pathname === 'string'
      || typeof opt.json === 'string')
    && pub.pub(
      new GetSubJson({
        pathname: opt.pathname,
        response: time(
          none => this.check(),
          opt.cache || 3400
        ),
      })
    ).pub(
      new PutSubJson({
        pathname: opt.pathname,
        response: time(
          none => this.correct()
        ),
      })
    ).pub(
      new PostSubJson({
        pathname: opt.pathname,
        response: time(
          none => this.call()
        ),
      })
    );

    return pub;
  }

}

const Submarine=class extends Communicable {
  constructor(opt){
    super();

    this.opt=Object.assign({}, opt);

    this.conn=new Conn(this.opt);

    this.downloads=Array.merge(
      this.fetch()
    ).map(
      opt => new Cont(
        typeof opt.files === 'object'
          ? opt
          : {
              conn: 'sh',
              files: opt,
            }
      )
    );
    this.uploads=this.downloads.map(
      cont => cont.to(this.opt)
    );
 
    this.files=Promise.all(
      this.uploads.map(
        cont => cont.files
      )
    );

  }

  fetch(){ return {}; }
  query(...files){ return {}; }
  format(stats){ return stats; }
  test(stats, ...files){ return {}; }
  command(tests, ...files){ return 'echo Hello Submarine'; }
  batch(tests, ...files){ return 'echo Hello Submarine'; }


  close(){
    return Promise.all(
      Array.merge(
        this.downloads,
        this.uploads
      ).map(
        cont => cont.close()
      )
    );
  }

  current(){
    return this.files.then(
      files => ({
        opt: Object.assign({}, this.opt),
        files: Object.assign(files),
        query: Object.assign(
          this.query(...files)
        ),
      })
    ).then(
      r => this.conn.query(
        r.query
      ).then(
        stats => Object.assign(r, {
          stats: this.format(stats),
        })
      )
    );
  }

  check(){
    return this.current(r => r).then(
      r => {
        const tests=this.test(
          r.stats,
          ...r.files
        );
        const list=tests.list(v => v);

        const good=list.filter(
          v => v
        ).length;

        const total=list.length;
        const bad=total - good;

        return Object.assign(r, {
          exams: {
            tests: tests,
            good: good,
            bad: bad,
            total: total,
            ok: good == total,
          },
        });
      }
    );
  }

  correct(){
    return this.check(r => r).then(
      r => r.exams.ok
        ? r
        : this.conn.run({
          cmd: this.command(
            Object.assign({
              stats: r.stats,
            }, r.exams),
            ...r.files
          ),
        }).then(
          exec => Object.assign(r, {
            exec: exec,
          })
        )
    );
  }

  call(){
    return this.check(r => r).then(
      r => r.exams.ok
        ? this.conn.run({
          cmd: this.batch(
            Object.assign({
              stats: r.stats,
            }, r.exams),
            ...r.files
          ),
        }).then(
          exec => Object.assign(r, {
            exec: exec,
          })
        )
        : r
    );
  }


  static chain(Sub, ...Subs){
    return class extends Chain {
      constructor(opt){
        super(
          none => new Sub(opt),
          0 < Subs.length
            ? new (
                Submarine.chain(
                  ...Subs
                )
              )(opt)
            : undefined
        );
      }
    };
  }


  static hosts(sub, ...hosts){
    return Submarine.collect(sub, {
      type: 'gen',
      coll: 'array',
      array: hosts,
    });
  }
  static collect(sub, ...opts){
    return class extends Collect {
      constructor(){
        super(time(
          () => coll(...opts).then(
            hosts => hosts.map(sub)
          ).catch(assert.collectError),
          1000 * 60 * 12
        ));
      }
    };
  }


}




const Chain=class extends Communicable {
  constructor(sub, next){
    super();

    this.sub=token(sub);
    this.next=
      hndl => next
        ? hndl(next)
        : undefined;
  }


  close(){
    return Promise.merge(
      this.sub().close(),
      this.next(
        next => next.close()
      )
    );
  }
 

  chained(hndl){
    return hndl(this.sub()).then(
      result => Promise.merge(
        result,

        Promise.merge(
          this.sub()
            .check()
        ).then(
          results => results.every(
            r => r.exams.ok
          ) ? this.next(hndl)
            : results
        )
      )
    );
  }


  current(){
    return this.chained(
      sub => sub.current()
    );
  }
  check(){
    return this.chained(
      sub => sub.check()
    );
  }
  correct(){
    return this.chained(
      sub => sub.correct()
    );
  }
  call(){
    return this.chained(
      sub => sub.call()
    );
  }

}


const Collect=class extends Communicable {
  constructor(subs){
    super();

    this.subs=(hndl=sub=>sub)=>{
      return subs().then(
        subs => subs.map(hndl)
      ).then(
        subs => Promise.all(subs)
      );
    };

  }

  close(){
    return this.subs(
      sub => sub.close()
    );
  }


  current(){
    return this.subs(
      sub => sub.current()
    );
  }
  complex(results){ return results; }
  check(){
    return this.subs(
      sub => sub.check()
    ).then(
      subs => this.complex(subs)
    );
  }
  correct(){
    return this.subs(
      sub => sub.correct()
    );
  }
  call(){
    return this.subs(
      sub => sub.call()
    );
  }

}



module.exports=Submarine;
