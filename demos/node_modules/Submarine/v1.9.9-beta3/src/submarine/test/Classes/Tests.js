'use strict';
const Submarine=require('submarine/Class');


const Test=class extends Submarine {
  testThisFuncIsCallable(){
    return 'callable';
  }
  fetch(){
    console.assert(
      this.testThisFuncIsCallable()
      == 'callable'
    , 'this.func is not callable');

    return [{
      conn: 'ssh',
      host: '10.10.10.17',
      files: {
        a: 'files/a.txt',
        b: 'files/b.txt',
        dir: 'files/dir',
      }.map(
        rel => `${__dirname}/${rel}`
      ),
    }];
  }
  query(files){
    console.assert(
      this.testThisFuncIsCallable()
      == 'callable'
    , 'this.func is not callable');

    return {
      a: `cat ${files.a}`,
      b: `cat ${files.b}`,
      c: `cat ${files.dir}/c.txt`,
      d: 'echo not formatted',
    };
  }
  
  format(stats){
    console.assert(
      this.testThisFuncIsCallable()
      == 'callable'
    , 'this.func is not callable');

    return {
      a: stats.a,
      b: stats.b,
      c: stats.c,
    };
  }

  test(stats, files){
    console.assert(
      this.testThisFuncIsCallable()
      == 'callable'
    , 'this.func is not callable');

    return {
      a: stats.a === 'a',
      b: stats.b === 'b',
      c: stats.c === 'c',
    };
  }

  batch(tests, files){
    console.assert(
      this.testThisFuncIsCallable()
      == 'callable'
    , 'this.func is not callable');

    return 'echo batch';
  }
}

const Test2=class extends Test {
  test(stats, files){
    return {
      a: stats.a === 'a',
      b: stats.b === 'b',
      c: stats.c === 'c',
      dummy: false,
    };
  }

  command(tests, files){
    return 'echo command';
  }
}



module.exports={
  Test: Test,
  Test2: Test2,
};
