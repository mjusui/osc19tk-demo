## Manage order of executions

`chain` function is prepared for management of execution order (`composite` function in v0.9x is migrated to `chain` function in v1.x).

```
const Submarine=require('Submarine');

const Step1=class extends Submarine {
  filepath(){
    return '/tmp/submarine/step1.txt';
  }
  query(){
    return {
      step: String.raw`
        test -r \
          ${this.filepath()} \
        && cat ${this.filepath()} \
        || echo ''
      `,
    };
  }

  test(stats){
    return {
      finished: !(stats.step === ''),
    };
  }

  command(){
    return String.raw`
      mkdir -p \
        $(dirname ${this.filepath()}) \
      && touch \
        ${this.filepath()} \
      && uuidgen -r \
        > ${this.filepath()}
    `;
  }
}


const Step2=class extends Step1 {
  filepath(){
    return '/tmp/submarine/step2.txt';
  }

  command(){
    return String.raw`
      cat \
        /tmp/submarine/step1.txt \
      > ${this.filepath()}
    `;
  }
}


const Steps=Submarine.chain(
  Step1,
  Step2
);

const steps=new Steps({
  conn: 'ssh',
  host: 'server1',
});


steps.check()
  .then(console.log)
.then(
  none => steps.correct()
    .then(console.log)
);
```

In this code, two steps(`Step1` and `Step2`) are in turn executed. `chain` function literally chains `Submarine` classes. This means that a class is not evaluated if the privious `check` is not passed. In `Step2`, '/tmp/submarine/step1.txt' is used, which is dependent with the process of `Step1` but `Step2` class does'nt have to inspect again the same tests of `Step1`, that is because `chain` function controls that `Step2` class is instantiated and runs command after all tests of `Step1` is passed.

